'use strict';

var internals = {};

exports.create = function (git_service, slack_notifier, webhook_notifier) {
  return {
    recordDeployment: internals.recordDeployment.bind(null, { git_service: git_service, slack_notifier: slack_notifier, webhook_notifier: webhook_notifier })
  };
};

internals.recordDeployment = async function (_ref, app_name, previous_tag_name, current_tag_name, message, target_environment) {
  var git_service = _ref.git_service,
      slack_notifier = _ref.slack_notifier,
      webhook_notifier = _ref.webhook_notifier;

  var changelog = void 0;
  if (message) {
    changelog = message;
  } else {
    changelog = await git_service.getChangesBetweenTags(previous_tag_name, current_tag_name);
  }
  return Promise.all([internals.sendSlackMessage(slack_notifier, app_name, previous_tag_name, current_tag_name, changelog, target_environment), webhook_notifier.sendDeploymentMessage(app_name, current_tag_name, target_environment, changelog)]);
};

internals.sendSlackMessage = function (slack_notifier, app_name, previous_tag_name, current_tag_name, changelog, target_environment) {
  var attachments = [internals.generateDeploymentSlackAttachment(current_tag_name, changelog)];
  var message = 'Deployed new version of *' + app_name + '* to ' + target_environment + '! :rocket:';
  return slack_notifier.sendDeploymentMessage(message, attachments);
};

internals.generateDeploymentSlackAttachment = function (current_tag_name, changelog) {
  return {
    fallback: changelog,
    fields: [{
      title: '' + current_tag_name,
      value: changelog,
      short: false
    }]
  };
};

/* istanbul ignore else */
if (process.env.NODE_ENV === 'test') {
  exports.internals = internals;
}