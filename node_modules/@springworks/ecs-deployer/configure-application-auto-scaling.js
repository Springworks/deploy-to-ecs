'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.configureApplicationAutoScaling = configureApplicationAutoScaling;

var _alarm = require('./alarm');

var _ecsCreator = require('./ecs-creator');

var ecs_creator = _interopRequireWildcard(_ecsCreator);

var _logger = require('./logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

async function configureApplicationAutoScaling(service, application_scaling) {
  _logger2.default.trace('Starting creation/updating of service autoscaling alarms/actions');

  const service_scaling_target = application_scaling.serviceScalingTarget;
  const alarms_and_actions = application_scaling.serviceScalingPolicies || application_scaling.alarmsAndActions;

  if (!service_scaling_target) {
    _logger2.default.warn('Missing service scaling target');
    return;
  }

  if (!alarms_and_actions) {
    _logger2.default.warn('Missing alarms configuration');
    return;
  }

  const valid_alarms_and_actions = alarms_and_actions.filter(alarm_and_action => (alarm_and_action.alarmName || alarm_and_action.alarm) && alarm_and_action.policy);

  if (!valid_alarms_and_actions || !valid_alarms_and_actions.length) {
    _logger2.default.warn('No valid alarms/actions found in deploy.json');
    return;
  }

  const cluster_name = service.clusterArn.split('/').pop();
  const service_name = service.serviceName;
  const resource_id = `service/${cluster_name}/${service_name}`;
  service_scaling_target.ResourceId = resource_id;
  service_scaling_target.ScalableDimension = 'ecs:service:DesiredCount';
  service_scaling_target.ServiceNamespace = 'ecs';
  const application_auto_scaling = ecs_creator.createApplicationAutoScaling();

  await application_auto_scaling.registerScalableTarget(service_scaling_target).promise();

  const alarms = [];

  for (const alarm_obj of valid_alarms_and_actions) {
    const policy = Object.assign({}, alarm_obj.policy, {
      ResourceId: resource_id,
      ScalableDimension: service_scaling_target.ScalableDimension,
      ServiceNamespace: service_scaling_target.ServiceNamespace,
      PolicyType: alarm_obj.policy.PolicyType || 'StepScaling'
    });
    const policy_arn_object = await application_auto_scaling.putScalingPolicy(policy).promise();
    alarms.push({
      alarm: alarm_obj.alarm,
      policy_arn: policy_arn_object.PolicyARN
    });
  }

  for (const { alarm, policy_arn } of alarms) {
    await (0, _alarm.create)(alarm, policy_arn);
  }
}